/* eslint-disable no-unused-expressions */
/**
 * Minified by jsDelivr using Terser v3.14.1.
 * Original file: /npm/geodesy@2.2.1/latlon-spherical.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import Dms from "./dms.js"; const π = Math.PI; class LatLonSpherical { constructor(t, a) { if (isNaN(t)) throw new TypeError(`invalid lat ‘${t}’`); if (isNaN(a)) throw new TypeError(`invalid lon ‘${a}’`); this._lat = Dms.wrap90(Number(t)), this._lon = Dms.wrap180(Number(a)) } get lat() { return this._lat } get latitude() { return this._lat } set lat(t) { if (this._lat = isNaN(t) ? Dms.wrap90(Dms.parse(t)) : Dms.wrap90(Number(t)), isNaN(this._lat)) throw new TypeError(`invalid lat ‘${t}’`) } set latitude(t) { if (this._lat = isNaN(t) ? Dms.wrap90(Dms.parse(t)) : Dms.wrap90(Number(t)), isNaN(this._lat)) throw new TypeError(`invalid latitude ‘${t}’`) } get lon() { return this._lon } get lng() { return this._lon } get longitude() { return this._lon } set lon(t) { if (this._lon = isNaN(t) ? Dms.wrap180(Dms.parse(t)) : Dms.wrap180(Number(t)), isNaN(this._lon)) throw new TypeError(`invalid lon ‘${t}’`) } set lng(t) { if (this._lon = isNaN(t) ? Dms.wrap180(Dms.parse(t)) : Dms.wrap180(Number(t)), isNaN(this._lon)) throw new TypeError(`invalid lng ‘${t}’`) } set longitude(t) { if (this._lon = isNaN(t) ? Dms.wrap180(Dms.parse(t)) : Dms.wrap180(Number(t)), isNaN(this._lon)) throw new TypeError(`invalid longitude ‘${t}’`) } static get metresToKm() { return .001 } static get metresToMiles() { return 1 / 1609.344 } static get metresToNauticalMiles() { return 1 / 1852 } static parse(...t) { if (0 == t.length) throw new TypeError("invalid (empty) point"); if (null === t[0] || null === t[1]) throw new TypeError("invalid (null) point"); let a = void 0, n = void 0; if (2 == t.length && ([a, n] = t, a = Dms.wrap90(Dms.parse(a)), n = Dms.wrap180(Dms.parse(n)), isNaN(a) || isNaN(n))) throw new TypeError(`invalid point ‘${t.toString()}’`); if (1 == t.length && "string" == typeof t[0] && ([a, n] = t[0].split(","), a = Dms.wrap90(Dms.parse(a)), n = Dms.wrap180(Dms.parse(n)), isNaN(a) || isNaN(n))) throw new TypeError(`invalid point ‘${t[0]}’`); if (1 == t.length && "object" == typeof t[0]) { const s = t[0]; if ("Point" == s.type && Array.isArray(s.coordinates) ? [n, a] = s.coordinates : (null != s.latitude && (a = s.latitude), null != s.lat && (a = s.lat), null != s.longitude && (n = s.longitude), null != s.lng && (n = s.lng), null != s.lon && (n = s.lon), a = Dms.wrap90(Dms.parse(a)), n = Dms.wrap180(Dms.parse(n))), isNaN(a) || isNaN(n)) throw new TypeError(`invalid point ‘${JSON.stringify(t[0])}’`) } if (isNaN(a) || isNaN(n)) throw new TypeError(`invalid point ‘${t.toString()}’`); return new LatLonSpherical(a, n) } distanceTo(t, a = 6371e3) { if (t instanceof LatLonSpherical || (t = LatLonSpherical.parse(t)), isNaN(a)) throw new TypeError(`invalid radius ‘${a}’`); const n = a, s = this.lat.toRadians(), i = this.lon.toRadians(), o = t.lat.toRadians(), e = o - s, r = t.lon.toRadians() - i, h = Math.sin(e / 2) * Math.sin(e / 2) + Math.cos(s) * Math.cos(o) * Math.sin(r / 2) * Math.sin(r / 2); return n * (2 * Math.atan2(Math.sqrt(h), Math.sqrt(1 - h))) } initialBearingTo(t) { if (t instanceof LatLonSpherical || (t = LatLonSpherical.parse(t)), this.equals(t)) return NaN; const a = this.lat.toRadians(), n = t.lat.toRadians(), s = (t.lon - this.lon).toRadians(), i = Math.cos(a) * Math.sin(n) - Math.sin(a) * Math.cos(n) * Math.cos(s), o = Math.sin(s) * Math.cos(n), e = Math.atan2(o, i).toDegrees(); return Dms.wrap360(e) } finalBearingTo(t) { t instanceof LatLonSpherical || (t = LatLonSpherical.parse(t)); const a = t.initialBearingTo(this) + 180; return Dms.wrap360(a) } midpointTo(t) { t instanceof LatLonSpherical || (t = LatLonSpherical.parse(t)); const a = this.lat.toRadians(), n = this.lon.toRadians(), s = t.lat.toRadians(), i = (t.lon - this.lon).toRadians(), o = Math.cos(a), e = 0, r = Math.sin(a), h = { x: o + Math.cos(s) * Math.cos(i), y: e + Math.cos(s) * Math.sin(i), z: r + Math.sin(s) }, l = Math.atan2(h.z, Math.sqrt(h.x * h.x + h.y * h.y)), M = n + Math.atan2(h.y, h.x), c = l.toDegrees(), p = M.toDegrees(); return new LatLonSpherical(c, p) } intermediatePointTo(t, a) { if (t instanceof LatLonSpherical || (t = LatLonSpherical.parse(t)), this.equals(t)) return new LatLonSpherical(this.lat, this.lon); const n = this.lat.toRadians(), s = this.lon.toRadians(), i = t.lat.toRadians(), o = t.lon.toRadians(), e = i - n, r = o - s, h = Math.sin(e / 2) * Math.sin(e / 2) + Math.cos(n) * Math.cos(i) * Math.sin(r / 2) * Math.sin(r / 2), l = 2 * Math.atan2(Math.sqrt(h), Math.sqrt(1 - h)), M = Math.sin((1 - a) * l) / Math.sin(l), c = Math.sin(a * l) / Math.sin(l), p = M * Math.cos(n) * Math.cos(s) + c * Math.cos(i) * Math.cos(o), d = M * Math.cos(n) * Math.sin(s) + c * Math.cos(i) * Math.sin(o), u = M * Math.sin(n) + c * Math.sin(i), L = Math.atan2(u, Math.sqrt(p * p + d * d)), m = Math.atan2(d, p), g = L.toDegrees(), N = m.toDegrees(); return new LatLonSpherical(g, N) } destinationPoint(t, a, n = 6371e3) { const s = t / n, i = Number(a).toRadians(), o = this.lat.toRadians(), e = this.lon.toRadians(), r = Math.sin(o) * Math.cos(s) + Math.cos(o) * Math.sin(s) * Math.cos(i), h = Math.asin(r), l = Math.sin(i) * Math.sin(s) * Math.cos(o), M = Math.cos(s) - Math.sin(o) * r, c = e + Math.atan2(l, M), p = h.toDegrees(), d = c.toDegrees(); return new LatLonSpherical(p, d) } static intersection(t, a, n, s) { if (t instanceof LatLonSpherical || (t = LatLonSpherical.parse(t)), n instanceof LatLonSpherical || (n = LatLonSpherical.parse(n)), isNaN(a)) throw new TypeError(`invalid brng1 ‘${a}’`); if (isNaN(s)) throw new TypeError(`invalid brng2 ‘${s}’`); const i = t.lat.toRadians(), o = t.lon.toRadians(), e = n.lat.toRadians(), r = n.lon.toRadians(), h = Number(a).toRadians(), l = Number(s).toRadians(), M = e - i, c = r - o, p = 2 * Math.asin(Math.sqrt(Math.sin(M / 2) * Math.sin(M / 2) + Math.cos(i) * Math.cos(e) * Math.sin(c / 2) * Math.sin(c / 2))); if (Math.abs(p) < Number.EPSILON) return new LatLonSpherical(t.lat, t.lon); const d = (Math.sin(e) - Math.sin(i) * Math.cos(p)) / (Math.sin(p) * Math.cos(i)), u = (Math.sin(i) - Math.sin(e) * Math.cos(p)) / (Math.sin(p) * Math.cos(e)), L = Math.acos(Math.min(Math.max(d, -1), 1)), m = Math.acos(Math.min(Math.max(u, -1), 1)), g = h - (Math.sin(r - o) > 0 ? L : 2 * π - L), N = (Math.sin(r - o) > 0 ? 2 * π - m : m) - l; if (0 == Math.sin(g) && 0 == Math.sin(N)) return null; if (Math.sin(g) * Math.sin(N) < 0) return null; const w = -Math.cos(g) * Math.cos(N) + Math.sin(g) * Math.sin(N) * Math.cos(p), D = Math.atan2(Math.sin(p) * Math.sin(g) * Math.sin(N), Math.cos(N) + Math.cos(g) * w), f = Math.asin(Math.min(Math.max(Math.sin(i) * Math.cos(D) + Math.cos(i) * Math.sin(D) * Math.cos(h), -1), 1)), R = o + Math.atan2(Math.sin(h) * Math.sin(D) * Math.cos(i), Math.cos(D) - Math.sin(i) * Math.sin(f)), S = f.toDegrees(), T = R.toDegrees(); return new LatLonSpherical(S, T) } crossTrackDistanceTo(t, a, n = 6371e3) { t instanceof LatLonSpherical || (t = LatLonSpherical.parse(t)), a instanceof LatLonSpherical || (a = LatLonSpherical.parse(a)); const s = n; if (this.equals(t)) return 0; const i = t.distanceTo(this, s) / s, o = t.initialBearingTo(this).toRadians(), e = t.initialBearingTo(a).toRadians(); return Math.asin(Math.sin(i) * Math.sin(o - e)) * s } alongTrackDistanceTo(t, a, n = 6371e3) { t instanceof LatLonSpherical || (t = LatLonSpherical.parse(t)), a instanceof LatLonSpherical || (a = LatLonSpherical.parse(a)); const s = n; if (this.equals(t)) return 0; const i = t.distanceTo(this, s) / s, o = t.initialBearingTo(this).toRadians(), e = t.initialBearingTo(a).toRadians(), r = Math.asin(Math.sin(i) * Math.sin(o - e)); return Math.acos(Math.cos(i) / Math.abs(Math.cos(r))) * Math.sign(Math.cos(e - o)) * s } maxLatitude(t) { const a = Number(t).toRadians(), n = this.lat.toRadians(); return Math.acos(Math.abs(Math.sin(a) * Math.cos(n))).toDegrees() } static crossingParallels(t, a, n) { if (t.equals(a)) return null; const s = Number(n).toRadians(), i = t.lat.toRadians(), o = t.lon.toRadians(), e = a.lat.toRadians(), r = a.lon.toRadians() - o, h = Math.sin(i) * Math.cos(e) * Math.cos(s) * Math.sin(r), l = Math.sin(i) * Math.cos(e) * Math.cos(s) * Math.cos(r) - Math.cos(i) * Math.sin(e) * Math.cos(s), M = Math.cos(i) * Math.cos(e) * Math.sin(s) * Math.sin(r); if (M * M > h * h + l * l) return null; const c = Math.atan2(-l, h), p = Math.acos(M / Math.sqrt(h * h + l * l)), d = o + c + p, u = (o + c - p).toDegrees(), L = d.toDegrees(); return { lon1: Dms.wrap180(u), lon2: Dms.wrap180(L) } } rhumbDistanceTo(t, a = 6371e3) { t instanceof LatLonSpherical || (t = LatLonSpherical.parse(t)); const n = a, s = this.lat.toRadians(), i = t.lat.toRadians(), o = i - s; let e = Math.abs(t.lon - this.lon).toRadians(); Math.abs(e) > π && (e = e > 0 ? -(2 * π - e) : 2 * π + e); const r = Math.log(Math.tan(i / 2 + π / 4) / Math.tan(s / 2 + π / 4)), h = Math.abs(r) > 1e-11 ? o / r : Math.cos(s); return Math.sqrt(o * o + h * h * e * e) * n } rhumbBearingTo(t) { if (t instanceof LatLonSpherical || (t = LatLonSpherical.parse(t)), this.equals(t)) return NaN; const a = this.lat.toRadians(), n = t.lat.toRadians(); let s = (t.lon - this.lon).toRadians(); Math.abs(s) > π && (s = s > 0 ? -(2 * π - s) : 2 * π + s); const i = Math.log(Math.tan(n / 2 + π / 4) / Math.tan(a / 2 + π / 4)), o = Math.atan2(s, i).toDegrees(); return Dms.wrap360(o) } rhumbDestinationPoint(t, a, n = 6371e3) { const s = this.lat.toRadians(), i = this.lon.toRadians(), o = Number(a).toRadians(), e = t / n, r = e * Math.cos(o); let h = s + r; Math.abs(h) > π / 2 && (h = h > 0 ? π - h : -π - h); const l = Math.log(Math.tan(h / 2 + π / 4) / Math.tan(s / 2 + π / 4)), M = Math.abs(l) > 1e-11 ? r / l : Math.cos(s), c = i + e * Math.sin(o) / M, p = h.toDegrees(), d = c.toDegrees(); return new LatLonSpherical(p, d) } rhumbMidpointTo(t) { t instanceof LatLonSpherical || (t = LatLonSpherical.parse(t)); const a = this.lat.toRadians(); let n = this.lon.toRadians(); const s = t.lat.toRadians(), i = t.lon.toRadians(); Math.abs(i - n) > π && (n += 2 * π); const o = (a + s) / 2, e = Math.tan(π / 4 + a / 2), r = Math.tan(π / 4 + s / 2), h = Math.tan(π / 4 + o / 2); let l = ((i - n) * Math.log(h) + n * Math.log(r) - i * Math.log(e)) / Math.log(r / e); isFinite(l) || (l = (n + i) / 2); const M = o.toDegrees(), c = l.toDegrees(); return new LatLonSpherical(M, c) } static areaOf(t, a = 6371e3) { const n = a, s = t[0].equals(t[t.length - 1]); s || t.push(t[0]); const i = t.length - 1; let o = 0; for (let a = 0; a < i; a++) { const n = t[a].lat.toRadians(), s = t[a + 1].lat.toRadians(), i = (t[a + 1].lon - t[a].lon).toRadians(); o += 2 * Math.atan2(Math.tan(i / 2) * (Math.tan(n / 2) + Math.tan(s / 2)), 1 + Math.tan(n / 2) * Math.tan(s / 2)) } (function (t) { let a = 0, n = t[0].initialBearingTo(t[1]); for (let s = 0; s < t.length - 1; s++) { const i = t[s].initialBearingTo(t[s + 1]), o = t[s].finalBearingTo(t[s + 1]); a += (i - n + 540) % 360 - 180, a += (o - i + 540) % 360 - 180, n = o } const s = t[0].initialBearingTo(t[1]); return a += (s - n + 540) % 360 - 180, Math.abs(a) < 90 })(t) && (o = Math.abs(o) - 2 * π); const e = Math.abs(o * n * n); return s || t.pop(), e } equals(t) { return t instanceof LatLonSpherical || (t = LatLonSpherical.parse(t)), !(Math.abs(this.lat - t.lat) > Number.EPSILON) && !(Math.abs(this.lon - t.lon) > Number.EPSILON) } toGeoJSON() { return { type: "Point", coordinates: [this.lon, this.lat] } } toString(t = "d", a) { if (!["d", "dm", "dms", "n"].includes(t)) throw new RangeError(`invalid format ‘${t}’`); if ("n" == t) return null == a && (a = 4), `${this.lat.toFixed(a)},${this.lon.toFixed(a)}`; return `${Dms.toLat(this.lat, t, a)}, ${Dms.toLon(this.lon, t, a)}` } } export { LatLonSpherical as default, Dms };
//# sourceMappingURL=/sm/910cd965e8c625f64b281b866b89c7bc818db2dec49ae5a9f1d1282135236ff3.map